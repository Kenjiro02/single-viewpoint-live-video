# -*- coding: utf-8 -*-
"""visual_expression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YIMDO64oWDaq7nWE8zzpT2Ld3_EpxHOt
"""

import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont

#方向線
direction_line = cv2.VideoCapture("./video/nc300274.mp4")#動画

#グローバル変数
pop_flag = False

#ズーム
def zoom_frames(frames:list, xmin:float, xmax:float, ymin:float, ymax:float) -> list:
  height, widht, _ = frames[0].shape
  box_width = xmax - xmin
  box_height = ymax - ymin
  zoom_x = int(xmax + xmin) / 2
  zoom_y = int(ymax + ymin) / 2
  zoom_range = -1
  if box_width > box_height:
    zoom_ragne = box_width / width
  else:
    zoom_range = box_height / height
  trim_xmin = zoom_x - width * zoom_range / 2
  trim_xmax = zoom_x + width * zoom_range / 2
  trim_ymin = zoom_y - height * zoom_range / 2
  trim_ymax = zoom_y + height * zoom_range / 2
  trim_frames = []
  for i in range(len(frames)):
    frame = frames[i]
    trim_frame = frame[int(trim_ymin) : int(trim_ymax), int(trim_xmin): int(trim_xmax)]
    try:
      trim_frame = cv2.resize(trim_frame, (width, height))
    except:
      trim_frame = frame
      print("can't RESIZE!!")
    trim_frames.append(trim_frame)

  return trim_frames

#方向線
def line_frames(frames:list) -> list:
  height, widht, _ = frames[0].shape
  line_frames = []
  line_speed_down = 2
  line_frame_count = 0
  line_frame = direction_line.read()
  for i in range(len(frames)):
    frame = frames[i]
    if line_frame_count % line_speed_down == 0:
      ret, line_frame = direction_line.read()
      if not ret:
        direction_line.set(cv2.CAP_PROP_POS_FRAMES, 0)
        ret, line_frame = direction_line.read()
      try:
        line_frame = cv2.resize(line_frame, (width, height))
      except:
        break
      line_frame_gray = cv2.cvtColor(line_frame, cv2.COLOR_BGR2GRAY)
      threshold = 100
      ret, line_frame_thresh = cv2.threshold(line_frame_gray, threshold, 255, cv2.THRESH_BINARY)
      line_frame = cv2.bitwise_and(line_frame, line_frame, mask = line_frame_thresh)
    frame = cv2.addWeighted(src1=frame,alpha=1,src2=line_frame,beta=0.2,gamma=0)
    line_frames.append(frame)
    line_frame_count+=1
  return line_frames

#画面分割
def split_frames(frames, df_performer_movement) -> list:
  height, widht, _ = frames[0].shape
  split_frames = []
  for frame in frames:
    split_img_list = []
    frame_width = width/3
    for row in df_performer_movement.itertuples():
      trim_center_y = (row.ymin + row.ymax) / 2
      #trim_width = row.xmax - row.xmin
      #trim_height = width * trim_width / height
      trim_height = row.ymax - row.ymin
      trim_width = trim_height * (frame_width/height)
      trim_frame = frame[int(trim_center_y - (trim_height/2) ): int(trim_center_y + (trim_height/2)), int(row.xmin): int(row.xmax)]
      trim_frame = cv2.resize(trim_frame, (int(frame_width), int(height)))
      split_img_list.append(trim_frame)
    split_frame = cv2.hconcat(split_img_list)
    split_frame = cv2.resize(split_frame, (width, height))
    split_frames.append(split_frame)

  return split_frames

#歌詞
def pil2cv(imgPIL):
    imgCV_RGB = np.array(imgPIL, dtype = np.uint8)
    imgCV_BGR = np.array(imgPIL)[:, :, ::-1]
    return imgCV_BGR

def cv2pil(imgCV):
    imgCV_RGB = imgCV[:, :, ::-1]
    imgPIL = Image.fromarray(imgCV_RGB)
    return imgPIL

def cv2_putText(img, text, org, fontFace, fontScale, color):
    x, y = org
    b, g, r = color
    colorRGB = (r, g, b)
    imgPIL = cv2pil(img)
    draw = ImageDraw.Draw(imgPIL)
    fontPIL = ImageFont.truetype(font = fontFace, size = fontScale)
    draw.text(xy = (x,y), text = text, fill = colorRGB, font = fontPIL)
    imgCV = pil2cv(imgPIL)
    return imgCV

def put_lyric(frames, times, lyric_second_list):#lyric_second_list[lyric, start, end]
  global pop_flag
  height, widht, _ = frames[0].shape
  lyric = lyric_second_list[0][0]
  start = lyric_second_list[0][1]
  end = lyric_second_list[0][2]
  lyric_frames = []
  for i in range(len(frames)):
    frame = frames[i]
    time = times[i]
    if start <= time < end:
      frame_copy = frame.copy()
      cv2.rectangle(frame_copy, (int(width*5/8)-50, int(height*3/4)-50), (int(width*5/8)+500, int(height*3/4)+90), (255, 255, 255), thickness=-1)
      frame = cv2.addWeighted(frame, 0.4, frame_copy, 0.6, 0)
      cv2.rectangle(frame, (int(width*5/8)-50, int(height*3/4)-50), (int(width*5/8)+500, int(height*3/4)+90), (0, 0, 0))
      frame = cv2_putText(frame, lyric, (int(width*5/8), int(height*3/4)), "./font/app_mincho.otf", 40, (0, 0, 0))
      pop_flag = True
    elif end <= time and pop_flag:
      lyric_second_list.pop(0)
      pop_flag = False
    lyric_frames.append(frame)

  return lyric_frames